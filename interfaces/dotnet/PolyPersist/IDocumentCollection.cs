 
// <auto-generated>
//     This code was generated by unicontract
//     see more information: https://github.com/gyorgy-gulyas/UniContract
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using System;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace PolyPersist
{
	/// The ICollection interface defines methods for CRUD operations on entities.
	/// This interface is used for collections that store entities.
	public interface IDocumentCollection<TDocument>
		where TDocument: IDocument, new()
	{
		/// Read-only property for parent Store.
		public IStore ParentStore { get; }
		/// Read-only property representing the name of the collection.
		public string Name { get; }

		/// Asynchronous method to insert an document into the collection.
		/// The 'document' parameter is the document that will be inserted into the collection.
		public Task Insert( TDocument document );
		/// Asynchronous method to update an existing document in the collection.
		/// The 'document' parameter represents the document to be updated in the collection.
		public Task Update( TDocument document );
		/// Asynchronous method to delete an document using its ID and PartitionKey.
		/// The 'id' parameter is the unique identifier of the document, and 'partitionKey' is used for partitioning the data in distributed data stores.
		public Task Delete( string partitionKey, string id );
		/// Asynchronous method to find an document by its ID and PartitionKey.
		/// The 'id' parameter is the unique identifier of the document, and 'partitionKey' is used to partition data.
		/// Returns the document if found, or null if not found.
		public Task<TDocument> Find( string partitionKey, string id );
		/// Getting the query interface for collection
		/// the return value is generic, so the implementation can define what are the real types
		/// In dotnet is can be IQueryable, in java it can be Java Streams, or Querydsl etc...
		public object Query();
		/// getting the underlying implementation
		/// please use this method carefully, because the returned value is different in every implementation
		public object GetUnderlyingImplementation();
	}
}
