 
// <auto-generated>
//     This code was generated by unicontract
//     see more information: https://github.com/gyorgy-gulyas/UniContract
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>

using System;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace PolyPersist
{
	public interface IColumnTable<TRow>
		where TRow: IRow, new()
	{
		/// Read-only property representing the name of the table.
		public string Name { get; }

		/// Asynchronous method to insert an row into the columntable.
		/// The 'row' parameter is the row that will be inserted into the table.
		public Task Insert( TRow row );
		/// Asynchronous method to update an existing row in the columntable.
		/// The 'row' parameter represents the row to be updated in the columntable.
		public Task Update( TRow row );
		/// Asynchronous method to delete an row using its ID and PartitionKey.
		/// The 'id' parameter is the unique identifier of the row, and 'partitionKey' is used for partitioning the data in distributed data stores.
		public Task Delete( string partitionKey, string id );
		/// Asynchronous method to find an row by its ID and PartitionKey.
		/// The 'id' parameter is the unique identifier of the row, and 'partitionKey' is used to partition data.
		/// Returns the row if found, or null if not found.
		public Task<TRow> Find( string partitionKey, string id );
		/// Getting the query interface for table
		/// the return value is generic, so the implementation can define what are the real types
		/// In dotnet is can be IQueryable, in java it can be Java Streams, or Querydsl etc...
		public object Query();
		/// getting the underlying implementation
		/// please use this method carefully, because the returned value is different in every implementation
		public object GetUnderlyingImplementation();
	}
}
